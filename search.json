[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "istatapi",
    "section": "",
    "text": "istatapi is a Python interface to discover and retrieve data from ISTAT API (The Italian National Institute of Statistics). The library is designed to explore ISTAT metadata and to retreive data in different formats. istatapi is built on top of ISTAT SDMX RESTful API.\nWhether you are an existing organization, a curious individual or an academic researcher, istatapi aims to allow you to easily access ISTAT databases with just a few lines of code. The library implements functions to:",
    "crumbs": [
      "Install"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "istatapi",
    "section": "Install",
    "text": "Install\nYou can easily install the library by using the pip command:\npip install istatapi",
    "crumbs": [
      "Install"
    ]
  },
  {
    "objectID": "index.html#tutorial",
    "href": "index.html#tutorial",
    "title": "istatapi",
    "section": "Tutorial",
    "text": "Tutorial\nFirst, let’s simply import the modules we need:\n\nfrom istatapi import discovery, retrieval\nimport matplotlib.pyplot as plt\n\nWith istatapi we can search through all the available datasets by simply using the following function:\n\ndiscovery.all_available()\n\n\n\n\n\n\n\ndf_id\nversion\ndf_description\ndf_structure_id\n\n\n\n\n0\n101_1015\n1.3\nCrops\nDCSP_COLTIVAZIONI\n\n\n1\n101_1030\n1.0\nPDO, PGI and TSG quality products\nDCSP_DOPIGP\n\n\n2\n101_1033\n1.0\nslaughtering\nDCSP_MACELLAZIONI\n\n\n3\n101_1039\n1.2\nAgritourism - municipalities\nDCSP_AGRITURISMO_COM\n\n\n4\n101_1077\n1.0\nPDO, PGI and TSG products: operators - municipalities data\nDCSP_DOPIGP_COM\n\n\n\n\n\nYou can also search for a specific dataset (in this example, a dataset on imports), by doing:\n\ndiscovery.search_dataset(\"import\")\n\n\n\n\n\n\n\ndf_id\nversion\ndf_description\ndf_structure_id\n\n\n\n\n10\n101_962\n1.0\nLivestock import export\nDCSP_LIVESTIMPEXP\n\n\n47\n139_176\n1.0\nImport and export by country and commodity Nace 2007\nDCSP_COEIMPEX1\n\n\n49\n143_222\n1.0\nImport price index - monthly data\nDCSC_PREIMPIND\n\n\n\n\n\nTo retrieve data from a specific dataset, we first need to create an instance of the DataSet class. We can use df_id, df_description or df_structure_id from the above DataFrame to tell to the DataSet class what dataset we want to retrieve. Here, we are going to use the df_id value. This may take a few seconds to load.\n\n# initialize the dataset and get its dimensions\nds = discovery.DataSet(dataflow_identifier=\"139_176\")\n\nWe now want to see what variables are included in the dataset that we are analysing. With istatapi we can easily print its variables (“dimensions” in ISTAT terminology) and their description.\n\nds.dimensions_info()\n\n\n\n\n\n\n\ndimension\ndimension_ID\ndescription\n\n\n\n\n0\nFREQ\nCL_FREQ\nFrequency\n\n\n1\nMERCE_ATECO_2007\nCL_ATECO_2007_MERCE\nCommodity Nace 2007\n\n\n2\nPAESE_PARTNER\nCL_ISO\nGeopolitics\n\n\n3\nITTER107\nCL_ITTER107\nTerritory\n\n\n4\nTIPO_DATO\nCL_TIPO_DATO12\nData type 12\n\n\n\n\n\nNow, each dimension can have a few possible values. istatapi provides a quick method to analyze these values and print their English descriptions.\n\ndimension = \"TIPO_DATO\" #use \"dimension\" column from above\nds.get_dimension_values(dimension)\n\n\n\n\n\n\n\nvalues_ids\nvalues_description\n\n\n\n\n0\nEV\nexport - value (euro)\n\n\n1\nTBV\ntrade balance - value (euro)\n\n\n2\nISAV\nimport - seasonally adjusted value - world based model (millions of euro)\n\n\n3\nESAV\nexport - seasonally adjusted value - world based model (millions of euro)\n\n\n4\nTBSAV\ntrade balance - seasonally adjusted value -world based model (millions of euro)\n\n\n5\nIV\nimport - value (euro)\n\n\n\n\n\nIf we do not filter any of our variables, the data will just include all the possible values in the dataset. This could result in too much data that would slow our code and make it difficult to analyze. Thus, we need to filter our dataset. To do so, we can simply use the values_ids that we found using the function get_dimension_values in the cell above.\nNote: Make sure to pass the names of the dimensions in lower case letters as arguments of the set_filter function. If you want to filter for multiple values, simply pass them as lists.\n\nfreq = \"M\" #monthly frequency\ntipo_dato = [\"ISAV\", \"ESAV\"] #imports and exports seasonally adjusted data\npaese_partner = \"WORLD\" #trade with all countries\n\nds.set_filters(freq = freq, tipo_dato = tipo_dato, paese_partner = paese_partner)\n\nHaving set our filters, we can now finally retrieve the data by simply passing our DataSet instance to the function get_data. It will return a pandas DataFrame with all the data that we requested. The data will be already sorted by datetime\n\ntrade_df = retrieval.get_data(ds)\ntrade_df.head()\n\n\n\n\n\n\n\nDATAFLOW\nFREQ\nMERCE_ATECO_2007\nPAESE_PARTNER\nITTER107\nTIPO_DATO\nTIME_PERIOD\nOBS_VALUE\nBREAK\nCONF_STATUS\nOBS_PRE_BREAK\nOBS_STATUS\nBASE_PER\nUNIT_MEAS\nUNIT_MULT\nMETADATA_EN\nMETADATA_IT\n\n\n\n\n0\nIT1:139_176(1.0)\nM\n10\nWORLD\nITTOT\nESAV\n1993-01-01\n10767\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n368\nIT1:139_176(1.0)\nM\n10\nWORLD\nITTOT\nISAV\n1993-01-01\n9226\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n372\nIT1:139_176(1.0)\nM\n10\nWORLD\nITTOT\nISAV\n1993-02-01\n10015\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n4\nIT1:139_176(1.0)\nM\n10\nWORLD\nITTOT\nESAV\n1993-02-01\n10681\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n373\nIT1:139_176(1.0)\nM\n10\nWORLD\nITTOT\nISAV\n1993-03-01\n9954\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n\n\n\nNow that we have our data, we can do whatever we want with it. For example, we can plot the data after having it cleaned up a bit. You are free to make your own analysis!\n\n# set matplotlib themes\nplt.style.use('fivethirtyeight')\nplt.rcParams['figure.figsize'] = [16, 5]\n\n#fiveThirtyEight palette\ncolors = ['#30a2da', '#fc4f30', '#e5ae38', '#6d904f', '#8b8b8b']\n\n# calculate moving averages for the plot\ntrade_df[\"MA_3\"] = trade_df.groupby(\"TIPO_DATO\")[\"OBS_VALUE\"].transform(\n    lambda x: x.rolling(window=3).mean()\n)\n\n#replace the \"TIPO_DATO\" column values with more meaningful labels\ntrade_df[\"TIPO_DATO\"] = trade_df[\"TIPO_DATO\"].replace(\n    {\"ISAV\": \"Imports\", \"ESAV\": \"Exports\"}\n)\n\n# Plot the data\nafter_2013 = trade_df[\"TIME_PERIOD\"] &gt;= \"2013\"\nis_ESAV = trade_df[\"TIPO_DATO\"] == \"Exports\"\nis_ISAV = trade_df[\"TIPO_DATO\"] == \"Imports\"\n\nexports = trade_df[is_ESAV & after_2013].rename(columns={\"OBS_VALUE\": \"Exports\", \"MA_3\": \"Exports - three months moving average\"})\nimports = trade_df[is_ISAV & after_2013].rename(columns={\"OBS_VALUE\": \"Imports\", \"MA_3\": \"Imports - three months moving average\"})\n\nplt.plot(\n    \"TIME_PERIOD\",\n    \"Exports\",\n    data=exports,\n    marker=\"\",\n    linestyle=\"dashed\",\n    color = colors[0],\n    linewidth=1\n)\nplt.plot(\n    \"TIME_PERIOD\",\n    \"Imports\",\n    data=imports,\n    marker=\"\",\n    linestyle=\"dashed\",\n    color = colors[1],\n    linewidth=1\n)\nplt.plot(\n    \"TIME_PERIOD\",\n    \"Exports - three months moving average\",\n    data=exports,\n    color = colors[0],\n    linewidth=2\n)\nplt.plot(\n    \"TIME_PERIOD\",\n    \"Imports - three months moving average\",\n    data=imports,\n    marker=\"\",\n    color = colors[1],\n    linewidth=2\n)\n\n# add a title\nplt.title(\"Italy's trade with the world\")\n\n# add a label to the x axis\nplt.xlabel(\"Year\")\n\n# turn y scale from millions to billions (divide by a 1000), and add a label\nplt.ylabel(\"Value in billions of euros\")\nplt.gca().yaxis.set_major_formatter(plt.FuncFormatter(lambda x, loc: \"{:,}\".format(int(x/1000))))\nplt.legend()\n\n\n\n\n\n\n\n\nWith just a few lines of code, we have been able to retrieve data from ISTAT and make a simple plot. This is just a simple example of what you can do with istatapi. You can find more examples in the _examples folder. Enjoy!",
    "crumbs": [
      "Install"
    ]
  },
  {
    "objectID": "discovery.html",
    "href": "discovery.html",
    "title": "Discovery",
    "section": "",
    "text": "This module implements functions to discover the data exposed by ISTAT. To do so, istatapi make metadata requests to the API endpoints. The Discovery module provides useful methods to parse and analyze API metadata responses. It makes use of the library pandas and returns data in the DataFrame format, making it convenient for interactive and exploratory analysis in Jupyter Notebooks.\nThe main class implemented in the Discovery module is DataSet.\nsource",
    "crumbs": [
      "Discovery"
    ]
  },
  {
    "objectID": "discovery.html#data-structures-and-information-about-available-datasets",
    "href": "discovery.html#data-structures-and-information-about-available-datasets",
    "title": "Discovery",
    "section": "Data Structures and Information about available Datasets",
    "text": "Data Structures and Information about available Datasets\n\nsource\n\nDataSet\n\n DataSet (dataflow_identifier:str, resource:str='datastructure')\n\nClass that implements methods to retrieve informations (metadata) about a Dataset\nThe class takes df_id, df_structure_id or df_description as inputs. These 3 values can be found by using the all_available() function.\n\nds = DataSet(dataflow_identifier=\"151_914\")\ntest_eq(ds.identifiers['df_id'], '151_914')\ntest_eq(ds.identifiers['df_description'], 'Unemployment  rate')\ntest_eq(ds.identifiers['df_structure_id'], 'DCCV_TAXDISOCCU1')\n\n\nds2 = DataSet(dataflow_identifier=\"22_289\")\ntest_eq(ds2.identifiers['df_id'], '22_289')\ntest_eq(ds2.identifiers['df_description'], 'Resident population  on 1st January')\ntest_eq(ds2.identifiers['df_structure_id'], 'DCIS_POPRES1')\n\n\n# test Dataset 729_1050 (https://github.com/Attol8/istatapi/issues/24)\nassert len(available_datasets.query('df_id == \"729_1050\"')) == 1\n# test that it raises ValueError if no dataset is found\ntest_fail(lambda: DataSet(dataflow_identifier=\"729_1050\"), contains=\"No available data found for the requested query\")\n\n\nds2.dimensions_info()\n\n\n\n\n\n\n\n\ndimension\ndimension_ID\ndescription\n\n\n\n\n0\nFREQ\nCL_FREQ\nFrequency\n\n\n1\nETA\nCL_ETA1\nAge class\n\n\n2\nITTER107\nCL_ITTER107\nTerritory\n\n\n3\nSESSO\nCL_SEXISTAT1\nGender\n\n\n4\nSTACIVX\nCL_STATCIV2\nMarital status\n\n\n5\nTIPO_INDDEM\nCL_TIPO_DATO15\nData type 15\n\n\n\n\n\n\n\nwe can look at the dimensions of a dataflow by simply accessing its attribute dimensions. However, we won’t have dimensions’ descriptions here.\n\nsource\n\n\nDataSet.dimensions_info\n\n DataSet.dimensions_info (dataframe=True, description=True)\n\nReturn the dimensions of a specific dataflow and their descriptions.\nTo have a look at the dimensions together with their description, we can use the dimension_info function. It will return an easy to read pandas DataFrame.\n\ndimensions_df = ds.dimensions_info()\ntest_eq(dimensions_df.columns, ['dimension', 'dimension_ID', 'description'])\ndimensions_df\n\n\n\n\n\n\n\n\ndimension\ndimension_ID\ndescription\n\n\n\n\n0\nFREQ\nCL_FREQ\nFrequency\n\n\n1\nCITTADINANZA\nCL_CITTADINANZA\nCitizenship\n\n\n2\nDURATA_DISOCCUPAZ\nCL_DURATA\nDuration\n\n\n3\nCLASSE_ETA\nCL_ETA1\nAge class\n\n\n4\nITTER107\nCL_ITTER107\nTerritory\n\n\n5\nSESSO\nCL_SEXISTAT1\nGender\n\n\n6\nTIPO_DATO\nCL_TIPO_DATO_FOL\nData type FOL\n\n\n7\nTITOLO_STUDIO\nCL_TITOLO_STUDIO\nLevel of education\n\n\n\n\n\n\n\nThe values that the different dimensions can take can also be explored. The available_values attribute contains a dictionary with the dimensions of the dataset as keys. The values of the dictionary are themselves dictionaries which can be accessed through the values_ids and values_description keys. The former key returns an ID of the dimension’s values, the latter a description of these values.\n\nvalues_dict = ds.available_values\ntest_eq(isinstance(values_dict, dict), True)\ntest_eq(list(values_dict.keys()).sort(), ds.dimensions.sort())\ntest_eq(values_dict['DURATA_DISOCCUPAZ']['values_ids'], ['TOTAL', 'M_GE12'])\ntest_eq(values_dict['DURATA_DISOCCUPAZ']['values_description'], ['total', '12 months and over'])\n\n\nsource\n\n\nDataSet.get_dimension_values\n\n DataSet.get_dimension_values (dimension, dataframe=True)\n\nReturn the available values of a single dimension in the dataset\n\nds.get_dimension_values('DURATA_DISOCCUPAZ')\n\n\n\n\n\n\n\n\nvalues_ids\nvalues_description\n\n\n\n\n0\nTOTAL\ntotal\n\n\n1\nM_GE12\n12 months and over\n\n\n\n\n\n\n\n\nsource\n\n\nDataSet.set_filters\n\n DataSet.set_filters (**kwargs)\n\nset filters for the dimensions of the dataset by passing dimension_name=value\n\n# test dataset from https://github.com/Attol8/istatapi/issues/25\nds = DataSet(dataflow_identifier = \"155_358\")\nassert 'WAGE_E_2021' not in ds.available_values['TIP_AGGR1']['values_ids']\n\nWith DataSet.set_filters() we can filter the dimensions of the dataset by passing the values that we want to filter for. The dataset will then only return data containing our filters. A dictionary with the selected filters is contained in the attribute DataSet.filters.\nNote that the arguments of DataSet.set_filters are lower case letters, but in DataSet.filters they are converted to upper case to be consistent with dimension names on ISTAT API.\n\ndz = DataSet(dataflow_identifier=\"139_176\")\ndz.set_filters(freq=\"M\", tipo_dato=[\"ISAV\", \"ESAV\"], paese_partner=\"WORLD\")\n\ntest_eq(dz.filters['FREQ'], 'M')\ntest_eq(dz.filters['TIPO_DATO'], [\"ISAV\", \"ESAV\"])\ntest_fail(lambda: dz.filters['freq']) #the filter is not saved in lower case",
    "crumbs": [
      "Discovery"
    ]
  },
  {
    "objectID": "retrieval.html",
    "href": "retrieval.html",
    "title": "Retrieval",
    "section": "",
    "text": "source\n\nmake_url_key\n\n make_url_key (filters:dict)\n\n\nsource\n\n\nget_data\n\n get_data (dataset:istatapi.discovery.DataSet, **kwargs)\n\nreturns a dataframe of the filtered ‘dataset’\n\n#initiate the dataset\ndataset = DataSet(dataflow_identifier=\"139_176\")\n\n#define some filters\nfreq = \"M\"\ntipo_dato=[\"ISAV\", \"ESAV\"]\npaese_partner=\"WORLD\"\n\n#set filters\ndataset.set_filters(freq=freq, tipo_dato=tipo_dato, paese_partner=paese_partner)\n#return dataset\ntrade_df = get_data(dataset)\ntrade_df.head()\ntest_eq(trade_df['FREQ'].unique(), ['M'])\ntest_eq(trade_df['TIPO_DATO'].unique().sort(), [\"ISAV\", \"ESAV\"].sort())\ntest_eq(trade_df['PAESE_PARTNER'].unique().sort(), [\"WORLD\"].sort())\ntest_eq(type(trade_df['TIME_PERIOD'].iloc[0]), pd._libs.tslibs.timestamps.Timestamp)\n\n\n# test annual dataset\ndataset = DataSet(dataflow_identifier=\"144_125\")\n\n#define some filters\nfreq = \"A\"\n\n#set filters\ndataset.set_filters(freq=freq)\n#return dataset\nannual_df = get_data(dataset)\n\ntest_eq(annual_df['FREQ'].unique(), ['A'])\ntest_eq(type(annual_df['TIME_PERIOD'].iloc[0]), pd._libs.tslibs.timestamps.Timestamp)\n\n\n# test another dataset\nds = DataSet(dataflow_identifier=\"22_315\")\nfreq = 'A'\nsesso = '9'\nitter107 = ['IT', 'ITG', 'ITF']\n\nds.set_filters(freq = freq, itter107 = itter107, sesso = sesso)\ndf = get_data(ds)\n\ntest_eq(df['FREQ'].unique(), ['A'])\ntest_eq(df['ITTER107'].unique().sort(), ['IT', 'ITF', 'ITG'].sort())\ntest_eq(df['SESSO'].unique(), [9])\ntest_eq(type(df['TIME_PERIOD'].iloc[0]), pd._libs.tslibs.timestamps.Timestamp)\n\n\n# test dataset from https://github.com/Attol8/istatapi/issues/24\n\nds = DataSet(dataflow_identifier=\"151_914\")\ndf = get_data(ds)\n\n# test that df is not empty\ntest_eq(df.empty, False)",
    "crumbs": [
      "Retrieval"
    ]
  },
  {
    "objectID": "utils.html",
    "href": "utils.html",
    "title": "Utils",
    "section": "",
    "text": "source\n\nstrip_ns\n\n strip_ns (tree)\n\nstrip all the namespaces from tree\n\nsource\n\n\nmake_tree\n\n make_tree (response)\n\nMake an ElementTree from the text of an XML response",
    "crumbs": [
      "Utils"
    ]
  },
  {
    "objectID": "base.html",
    "href": "base.html",
    "title": "Base",
    "section": "",
    "text": "source\n\nget_custom_ssl_session\n\n get_custom_ssl_session ()\n\nGet a session with a custom ssl context\n\nsource\n\n\nCustomHttpAdapter\n\n CustomHttpAdapter (ssl_context=None, **kwargs)\n\nTransport adapter” that allows us to use custom ssl_context.\n\nsource\n\n\nISTAT\n\n ISTAT ()\n\nBase class that provides useful functions to communicate with ISTAT API\n\nsource\n\n\nISTAT._request\n\n ISTAT._request (path, **kwargs)\n\nMake a request to ISTAT API given a ‘path’\nThe ‘ISTAT’ class already implements the ‘base_url’, therefore ‘path’ only needs to include the other parameters of the request. Here is an example of a succesful request:\n\nistat = ISTAT()\npath = \"dataflow/IT1\"\ntest_response = istat._request(path=path)\ntest_response\n\n&lt;Response [200]&gt;",
    "crumbs": [
      "Base"
    ]
  }
]