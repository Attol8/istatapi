# AUTOGENERATED! DO NOT EDIT! File to edit: 01_discovery.ipynb (unless otherwise specified).

__all__ = ["DataFlows", "DataSet"]

# Cell
from .base import ISTAT
from .utils import make_tree, strip_ns
import pandas as pd
import pprint

# Cell
# TODO: eliminate class, it's not needed
class DataFlows(ISTAT):
    """Base class to explore available Dataflows"""

    def __init__(self):
        super().__init__()
        self.resource = "dataflow"
        self.available = self.all_available()

    def parse_dataflows(self, response):
        """parse the `response` containing all the available datasets and return a list of dataflows."""
        tree = make_tree(response)
        strip_ns(tree)
        root = tree.root

        dataflows_l = []
        for dataflow in root.iter("Dataflow"):
            id = dataflow.get("id")
            version = dataflow.get("version")
            structure_id = [ref.get("id") for ref in dataflow.iter("Ref")][0]

            # iter over names and get the descriptions
            for name in dataflow.findall("Name"):
                lang = name.get("{http://www.w3.org/XML/1998/namespace}lang")
                if lang == "en":
                    description_en = name.text
                # if lang == 'it':
                # description_it = name.text

            dataflow_dict = {
                "df_id": id,
                "version": version,
                "description": description_en,
                # "description_it": description_it,
                "df_structure_id": structure_id,
            }

            dataflows_l.append(dataflow_dict)

        return dataflows_l

    def all_available(self, dataframe=True):
        """Return all available dataflows"""
        path = "dataflow/IT1"
        response = self._request(path=path)
        dataflows = self.parse_dataflows(response)

        if dataframe == True:
            dataflows = pd.DataFrame(dataflows)

        return dataflows

    def search(self, keyword):
        """Search available dataflows that contain `keyword`. Return these dataflows in a DataFrame"""
        dataflows = self.available[
            self.available["description"].str.contains(keyword, case=False)
        ]

        return dataflows


# Cell
class DataSet(ISTAT):
    """Class that implements methods to retrieve informations (metadata) about a Dataset"""

    def __init__(self, dataflow_identifier):
        super().__init__()
        self.resource = "datastructure"
        self.all_available = (
            DataFlows().available
        )  # df with all the available dataflows
        self.identifiers = self.set_identifiers(dataflow_identifier)
        self.dimensions = self.get_dimensions(description=False).dimension.tolist()
        self.dimensions_values = self.available_dimensions_values()

        # TODO: returning all metadata related to the dataflow contained in 'Header'

    def set_identifiers(self, dataflow_identifier):
        """"""
        if dataflow_identifier[3] == "_":
            return self.set_from_id(dataflow_identifier)
        elif dataflow_identifier[4] == "_":
            return self.set_from_structure_id(dataflow_identifier)
        else:
            if type(dataflow_identifier) == str:
                return self.set_from_description(dataflow_identifier)
            else:
                raise ValueError(dataflow_identifier)

    def set_from_id(self, df_id):
        mask = self.all_available["df_id"] == df_id
        df = self.all_available[mask]
        return df.to_dict(orient="records")[0]

    def set_from_structure_id(self, df_structure_id):
        mask = self.all_available["df_structure_id"] == df_structure_id
        df = self.all_available[mask]
        return df.to_dict(orient="records")[0]

    def set_from_description(self, description):
        mask = self.all_available["description"] == description
        df = self.all_available[mask]
        return df.to_dict(orient="records")[0]

    def parse_dimensions(self, response):
        """Parse the `response` containing a dataflow's dimensions and return them in a list"""
        tree = make_tree(response)
        strip_ns(tree)
        root = tree.root

        dimensions_l = []
        for dimension in root.iter("Dimension"):
            dimension_name = dimension.attrib["id"]

            dimension_id = [
                enumeration.find("Ref").get("id")
                for enumeration in dimension.iter("Enumeration")
            ][0]

            dimension_dict = {"dimension": dimension_name, "dimension_ID": dimension_id}

            dimensions_l.append(dimension_dict)

        return dimensions_l

    def get_dimensions(self, dataframe=True, description=True):
        """Return the dimensions and their descriptions of a specific dataflow."""
        df_structure_id = self.identifiers["df_structure_id"]

        path_parts = [self.resource, self.agencyID, df_structure_id]
        path = "/".join(path_parts)
        response = self._request(path=path)
        dimensions = self.parse_dimensions(response)

        if dataframe == True:
            dimensions = pd.DataFrame(dimensions)

        if description == True:
            dimensions_description = self.dimensions_description(dimensions)
            dimensions = dimensions.merge(dimensions_description, on="dimension_ID")

        return dimensions

    def get_dimension_id(self, dimension):
        """Convert `dimension` to `dimension_id`"""
        dimensions_df = self.get_dimensions(description=False)
        mask = dimensions_df["dimension"] == dimension
        dimension_ID = dimensions_df[mask]["dimension_ID"]
        return dimension_ID.values[0]

    def dimensions_description(self, dimensions):
        """Return a dataframe with the descriptions of `dimensions`"""
        resource = "codelist"
        dimensions_l = dimensions.dimension_ID.tolist()
        descriptions_l = []

        for dimension_id in dimensions_l:
            path_parts = [resource, self.agencyID, dimension_id]
            path = "/".join(path_parts)
            response = self._request(path=path)
            tree = make_tree(response)
            strip_ns(tree)
            root = tree.root

            description = [x for x in root.iter("Codelist")][0]
            # description_it = description.findall('Name')[0].text
            description = description.findall("Name")[1].text

            description_dict = {
                "dimension_ID": dimension_id,
                "description": description,
            }
            descriptions_l.append(description_dict)

        dimensions_descriptions = pd.DataFrame(descriptions_l)

        return dimensions_descriptions

    def dimension_values(self, dimension, dataframe=True):
        """Return ALL the possible values of a dimension in the dataset"""
        # TODO: convert dimension_ID to dimension name to be consistent
        resource = "codelist"
        dimension_ID = self.get_dimension_id(dimension)
        path_parts = [resource, self.agencyID, dimension_ID]
        path = "/".join(path_parts)
        response = self._request(path=path)
        tree = make_tree(response)
        strip_ns(tree)
        root = tree.root

        values = []
        for value in root.iter("Code"):
            value_id = value.get("id")
            # value_it = value.findall('Name')[0].text
            value = value.findall("Name")[1].text

            value_dict = {"value_ID": value_id, "description": value}

            values.append(value_dict)

        if dataframe == True:
            values = pd.DataFrame(values)

        return values

    def available_dimensions_values(self):
        """Return a dictionary with available values for each dimension in the dataset"""
        resource = "availableconstraint"
        df_id = self.identifiers["df_id"]
        path_parts = [resource, df_id]
        path = "/".join(path_parts)
        response = self._request(path=path)
        tree = make_tree(response)
        strip_ns(tree)
        root = tree.root

        dimension_values = {}

        for dimension in root.iter("KeyValue"):
            dimension_id = dimension.get("id")
            values = [value.text for value in dimension.iter("Value")]
            dimension_values[dimension_id] = values

        return dimension_values
